# msg4r



序列化、反序列化工具。

## 问题

目前有很多序列化、反序列化需求，限定了数据表示格式，不能采用常见的JSON、XML、Apache Thrift、Google Protobuf来解决。

可以用来定义数据格式的通用库，例如MFC的文档序列化框架、boost::serialization，都有与目标格式冲突且无法兼容的框架特有的数据。

依据数据格式规范编制解析程序，已经有很多方法，非常繁琐、容易出错。最大的问题是，它不能支持在异步IO或非阻塞IO条件下，对chunked数据流的支持。它适合先用消息载体（例如MQ消息），而不是直接解析流不引入载体格式的情形。

chunked流每次读取到的字节数随机，且大概率少于一条完整的消息的字节数。
如果要成功完成一条消息的解析，已经接收到的字节数应至少有解析这条消息所需的字节数。
如果收到的字节数不足，无法完成解析，则必须等待之后的字节。

### 等待一个固定周期

比较直接的方法是等待一段时间。等待之后如果仍然不能够凑齐，继续下一个等待周期。
这个办法，等待周期的长度不好确定。等待时间长，性能太差；等待时间短，CPU使用率太高，而且同步协议（半双工）性能也差。

对于无长度域的消息，只有解析器报告“数据充足”才是有效的终止条件之一。“等待了x秒，x充分大”这样的条件无法证明数据接收完成，因此采用等待充分久是不正确的解析方法。

### 反复偿试解析

在没有长度域的情况下，采取反复偿试解析缓冲区的办法。
如果数据不足，终止解析，复位缓冲指针位置，等收到新数据之后再次偿试，如此反复，直到成功为止。

极端的情况，如果一个n个字节的消息，每次只收到1个字节，分n次收完，则偿试解析的次数是n次，
每次解析的字节数量分别是1, 2, 3...n，共1 + 2 + 3 + ... + n = n * (n + 1) / 2,增长率是O(n^2)。

如果没有采用Devide-and-Conque或Reduce-and-Conque方法，直接解析，代码圈复杂度很高，很难证明或验证代码有效性，
只能靠在生产环境上报错并修复的方法来除错。

例如，复位缓冲区指针位置，或者删除缓冲区头部的旧数据等。

## 目标

探索异步IO、非阻塞IO条件下，支持chunked流解析的声明式序列化、反序列化解决方案。

例如，有数据表示如下：

```
struct my_struct {
  uint32_t id;
  std::string name;
  std::map<std::string, std::string> props;
};
```

解析程序可以类似如下：

```
enum decode_state {
  DECODE_SUCCESS    = 0;
  DECODE_INPROGRESS = 0;
  DECODE_FAILURE    = 0;
}

...

struct my_struct_parser {
  ..
  decode_state operator()(std::istream& is, my_struct& t) {
    BEGIN_PARSER(t)
      PARSE(t.id)
      PARSE(t.name)
      PARSE(t.props)
    END_PARSER(t)
  }
  ..
};
```

直接声明字段列表即可，不用管内部结构以及解析的时候会遇到何种问题，以及该如何处理。
嵌套的数据结构，可以递归处理，只需声明当前数据的解析。

## 理论依据

任何一个非平凡（一步到位）的问题，都可以表示为一个可递归的子问题列表。

此表示是递归的。

数学归纳法：
对于平凡的问题，有解；
对于某一个非平凡问题表示成的子问题列表中，所有的子问题都已经有解，那么这个问题就可解。




